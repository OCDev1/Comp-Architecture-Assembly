.extern printf
.extern scanf

.section .data

.section .rodata
pstrlen_print_fmt:
    .string "first pstring length: %d, second pstring length: %d\n"

swapCase_print_fmt:
    .string "length: %d, string: %s\n"

swapCase_print_fmt2:
    .string "length: %d, string: %s"

test_print_fmt:
    .string "made it to pstring"

.section .text
.globl pstrlen
.type	pstrlen, @function
pstrlen:
     # Enter
        pushq %rbp
        movq %rsp, %rbp

        # make a counter out of r11
          xor %r11, %r11
          mov %rdi, %r13      # saving string address in r13
        # loop to count the string, length kept in r11
                .loop2:
                    # Read byte from string
                    movb (%r13), %al

                    # If were at the end of the string, exit
                    cmpb $0x0, %al
                    je .done

                    # else continue counting
                    jne .next2

                .next2:
                    # Increment the pointer and counter, and continue to next iteration
                    inc %r11
                    incq %r13
                    jmp .loop2

        .done:
            # put the result in rax and return
            dec %r11
            movq %r11, %rax

# Exit
     xor %rdi, %rdi
     xor %rsi, %rsi
     xor %rdx, %rdx
    movq %rbp, %rsp
    popq %rbp
    ret

#-------------------------------------------------

.globl swapCase
.type	swapCase, @function
swapCase:
     # Enter
        pushq %rbp
        movq %rsp, %rbp

 # Change every instance of small caps to big and vice-versa
 # save original adress in r12
 mov %rdi, %r12

  # make a counter out of r11
           xor %r11, %r11

# the loop
.loop21:
    # Read byte from string
    movb (%rdi), %al
    add $0x1, %r11

    # If at the end of the string, exit
    cmpb $0x0, %al
    je .done2

    # If the byte is small, change it to caps
    cmpb $0x61, %al
    jge .lowerSecCheck      # possibly lower case letter

    # If the byte is caps, change it to small
    cmpb $0x41, %al
    jge .upperSecCheck      # possibly upper case letter

.next21:
    # Increment the pointer and counter , and continue to next iteration
    incq %rdi
    jmp .loop21

.lowerSecCheck:
    cmpb $0x7A, %al
    jle .lowerToUpper       # confirmed lower case letter
    jmp .next21                   # not a letter at all

.upperSecCheck:
    cmpb $0x5A, %al
    jle .upperToLower       # confirmed upper case letter
    jmp .next21                   # not a letter at all

.lowerToUpper:
    subb $0x20, %al
    movb %al, (%rdi)
    jmp .next21

.upperToLower:
    addb $0x20, %al
    movb %al, (%rdi)
    jmp .next21

.done2:
    #   put the new string in rax and return
    inc %r12
    mov %r12, %rax

# Exit
    xor %rdi, %rdi
    xor %rsi, %rsi
    xor %rdx, %rdx
    movq %rbp, %rsp
    popq %rbp
    ret



