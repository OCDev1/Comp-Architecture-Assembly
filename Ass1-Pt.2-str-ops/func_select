.extern printf
.extern scanf
.extern pstrlen
.extern swapCase

.section .data

.section .rodata
pstrlen_print_fmt:
    .string "first pstring length: %d, second pstring length: %d"

swapCase_print_fmt:
    .string "length: %d, string: %s\n"

.section .text
.globl run_func
.type	run_func, @function
run_func:
    # Enter
    pushq %rbp
    movq %rsp, %rbp

    xor %r12, %r12
    xor %r13, %r13
    xor %r14, %r14

    # saving arguments in registers
    mov %rdi, %r12      # saving choice in r12
    mov %rsi, %r13      # saving 1st string address in r13
    mov %rdx, %r14      # saving 2nd string address in r14

    # if choice is 31 call pstrlen
    cmp $0x1F, %rdi
    je .pstrlenCall

    # if choice is 33 call swapCase
    cmp $0x21, %rdi
    je .swapCaseCall

    # if choice is 34 call psrijcpy
    cmp $0x22, %rdi
    je .pstrlenCall

.pstrlenCall:
        # first return val will be saved in r10
        mov %r13, %rdi
        call pstrlen        # first call
        mov %rax, %r10
        xor %rdi, %rdi
        xor %rsi, %rsi
        xor %rdx, %rdx

        # second return val will be saved in r15
        mov %r14, %rdi
        call pstrlen        # second call
        mov %rax, %r15

        # print the final text with values
        movq $pstrlen_print_fmt, %rdi
        movq %r10, %rsi     # first val
        movq %r15, %rdx     # second val
        call printf
# Exit
    xorq %rax, %rax
    movq %rbp, %rsp
    popq %rbp
    ret

.swapCaseCall:
        # first return pointer will be saved in r10
                mov %r13, %rdi
                call swapCase        # first call
                mov %rax, %r10       # save return val in r10
                xor %rdi, %rdi
                xor %rsi, %rsi
                xor %rdx, %rdx

                # Print the result
                xor %rsi, %rsi
                movq $swapCase_print_fmt, %rdi      # text
                mov $0x0, %rsi                      # number
                xor %rdx, %rdx
                movq %r10, %rdx                     # string
                xorq %rax, %rax
                call printf

        # second return pointer will be saved in r10
                mov %r14, %rdi
                call swapCase        # second call
                mov %rax, %r10       # save return val in r10
                xor %rdi, %rdi
                xor %rsi, %rsi
                xor %rdx, %rdx

        # Print the result
                xor %rsi, %rsi
                movq $swapCase_print_fmt, %rdi      # text
                mov $0x0, %rsi                      # number
                xor %rdx, %rdx
                movq %r10, %rdx                     # string
                xorq %rax, %rax
                call printf


 # Exit
    xorq %rax, %rax
    movq %rbp, %rsp
    popq %rbp
    ret
